\documentclass[11pt]{article}
\usepackage{fullpage}
\usepackage[utf8]{inputenc}
\usepackage{listings}
\usepackage{amssymb}


\lstset{basicstyle=\footnotesize, numbers=left, numberstyle=\footnotesize,
  stepnumber=1, numbersep=5pt, captionpos=b, frame=single,
  showstringspaces=false}

\begin{document}

DistAlgo is a high-level language for writing distributed algorithms, such that
they serve as both clear specifications and runnable implementations of those
algorithms. This document provides a brief, practical introduction to the major
features of the language using several iterations of a familiar example.

DistAlgo is currently implemented as an extension of the Python language, and
requires Python 3.4 or higher. This tutorial assumes some familiarity with
Object-Oriented programming in general, and with Python, in particular.

Let's begin with the simplest possible version of ``Hello World'' written in
DistAlgo.

\lstset{language={python}, morekeywords={send, sent, received, each, some,
    await, new, setup, start, run, process}}

\begin{lstlisting}[caption={hello\_world01.da - Main Function Definition}, label={lst:hw01}]
    def main():
        print('Hello World.')
\end{lstlisting}

\noindent Every DistAlgo program must have a main function. In this case, the body of
\texttt{main} merely contains a call to Python's print function, to output
``Hello World'' to standard output. As we will see in the next example, the
inteded use of the main function in a DistAlgo program is to create, prepare,
and then begin the execution of the distinct processes that participate in the
distributed algorithm.

In the second version of ``Hello World'' we can see how process definition and
creation works in a DistAlgo program.

\begin{lstlisting}[caption={hello\_world02.da - Process Definition}, label={lst:hw02}]
  class P (process):
      def setup(name):
          pass

      def run():
          output('Hello World from:', self.name, ', AKA:', self.id)

  def main():
      ps = new(P)
      setup(ps, ('bob',))
      start(ps)
\end{lstlisting}

\noindent Distributed algorithms are constituted by the interaction of multiple, distinct
processes. DistAlgo is intended for the implementation of distributed
algorithms. To that end, DistAlgo makes it easy to define new process types
that will execute the behavior required by the algorithm.

Every user defined process type in DistAlgo is an extension of the base class
\texttt{process}. In the second version of ``Hello World'' we define a class
called \texttt{P}, which extends \texttt{process}. In order to properly define
a new type of DistAlgo process, the user must define two functions:
\texttt{setup} and \texttt{run}.

The \texttt{setup} method is used to declare and initialize any instance
variables of the user's new process class. Any parameters of the setup method
are implicitly declared as instance variables and initialized with the value
passed as the argument to the parameter. In the second example, \texttt{setup}
has one parameter \texttt{name}, which is initialized with the value
\texttt{'bob'}. In addition, every instance of a distalgo process has a unique
identifier stored in an instance variable, \texttt{self.id}, which is the pair
of the IP address and the port number upon which the process instance is
listening.

The \texttt{run} method of a DistAlgo process contains the definition of the
behavior of the process. For the example in listing 2, the process merely
prints a ``Hello World'' message, identifying itself using both the name we
supplied as an argument and its unique id.

In this second example we can also see a proper use of the \texttt{main} method
of a DistAlgo program. Here we have calls to three Distalgo methods:
\texttt{new}, \texttt{setup}, and \texttt{start}.

The \texttt{new} method is used to instantiate a set of DistAlgo process
instances. We supply the classname of the process class we wish to instantiate,
\texttt{P}, as an argument, and \texttt{new} returns a set of references to the
new process instances. In this case we store the set in the variable
\texttt{ps}.  If the class name is the only argument, then \texttt{new} creates
just one instance of that process class. However, even if \texttt{new} is used
to create just once process instance, the returned value is still a set--in
this case a singleton set--containing a reference to that process instance.

The \texttt{setup} method is used to initialize our new process instances. The
first argument is a set of process instance references. The second argument is
a tuple of arguments to be passed to the parameters of the \texttt{setup}
method defined for the process class corresponding to the class of the process
instances one is trying to initialize. Note, even if there is only one argument
passed to the \texttt{setup} method of the process class, it must still be
packaged within a singleton tuple.

Finally, we can begin the execution of the process instances by passing a set
of references to those process instances to the \texttt{start} method. The call
to \texttt{start} will cause the \texttt{run} method defined within the
corresponding process class to begin executing at each process instance
included in the call to \texttt{start}.

In the third example, we can see how multiple process instances are created.

\begin{lstlisting}[caption={hello\_world03.da - Multiple Process Instances}, label={lst:hw03}]
  class P (process):
      def setup(name):
          pass

      def run():
          output('Hello World from:', name, ', AKA:', self.id)

  def main():
      num_processes = 2
      ps = new(P, num = num_processes)
      setup(ps, ('bob', ))
      start(ps)

\end{lstlisting}

\noindent You can run this program from the command line by entering:
``python3 -m da hello\_world3.da''.

This program is very similar to ``hello\_world2.da''. In fact, the definition of
the process class, \texttt{P}, is identical to the one given in the previous
example. There are just two changes in \texttt{main}. First, we add a new
variable, \texttt{num\_processes}, which is initialized to $2$. Second, we pass
this new variable as the argument to the \texttt{num} parameter of the
\texttt{new} method, resulting in the instantiation of two process instances of
the process class, \texttt{P}. These two instances are both initialized by the
call to \texttt{setup}, and then set running by the call to \texttt{start}.

The instantiation and execution of the two process instances can be observed in
the output when the program is run. There will be two ``Hello World'' outputs,
each with a distinct value for \texttt{self.id}, though both will claim that
their name is 'bob', since they are both inititialized with the same parameter.
You should think about how you might initialize the \texttt{name} fields of
these two process instances with distinct values.

This latest version of hello\_world features two DistAlgo process instances,
but they do not interact with or even refer to each other. Distributed
algorithms are intended to feature this sort of interplay between distinct
processes, so let's add some in the next example.

Here is the fourth example:

\begin{lstlisting}[caption={hello\_world04.da - Multiple Processes Referring to Each Other}, label={lst:hw04}]
class P (process):
    def setup(processes):
        pass

    def run():
        for p in processes:
            output(self.id, 'says Hello to: ', p)

def main():
    num_processes = 2
    ps = new(P, num = num_processes)
    setup(ps, (ps,))
    start(ps)  
\end{lstlisting}

\noindent You can run this program from the command line by entering:
``python3 -m da hello\_world04.da''. There are several changes to the program.
First, we have altered the definition of the \texttt{setup} method so that it
accepts parameter, \texttt{processes}, which will hold a set of references to
DistAlgo process instances. Next, we have altered the the \texttt{run} method
of \texttt{P} so that instead of greeting the entire world, it instead loops
over all the process instances in \texttt{processes} and sends each of them
an individualized greeting, <process id> says Hello to <process id>. 

Within the main method we generate two distinct process instances of type
\texttt{P}, and store the set of their references in texttt{ps}. We then
initialize both instances passing that same set of references to \texttt{setup}
to serve as the argument to texttt{processes}. Finally, we start those process
instances running as before.

If you run the program then you will see that in the ouput there are four
``X say Hello to Y''. If we label the two process instances, $p1$ and $p2$,
then the four greetings have the following forms: i) ``p1 says Hello to p1'';
ii) ``p1 says Hello to p2''; iii) ``p2 says Hello to p1'';
iv) ``p2 says Hello to p2'', in some arbitrary order. But, we probably did not
intend to have the processes greeting themselves. So what went wrong?

The problem occurs on line 12. We passed the entire set ps to the
\texttt{processes} parameter of \texttt{P} for each process instance, but there
is a reference to that process instance in the set \texttt{ps}. So, each ends
up with a \texttt{processes} set that contains a reference to itself. How can
we avoid this?

It turns out there is a common pattern present in many DistAlgo examples that
allows one to initialize a process with a set of references to other process
instances, but exclude a reference to the process instance one is attempting to
initialize. It is illustrated in Example 6:

\begin{lstlisting}[caption={hello\_world06.da - Excluding Self-References, the Nice Way}, label={lst:hw06}]
class P (process):
    def setup(processes):
        pass

    def run():
        for p in processes:
        output(self.id, 'says Hello to: ', p)

def main():
    num_processes = 2
    ps = new(P, num = num_processes)
    for p in ps:
        setup(p, (ps - {p}, ))
    start(ps)
\end{lstlisting}

The only difference between Example 6 and Example 4 occurs inside the call to
the \texttt{setup} method within main. We initialize each of the process
instances one at a time within a loop. For each process instance, instead of
passing the entire set \texttt{ps} to the \texttt{processes} paramter of
\texttt{P}, we instead pass the set produced taking the difference of
\texttt{ps} with a singlton set that contains a reference to the process
instance being initialized. Thus, each process instance is set up with a set of
refereces to every other process instance in \texttt{ps}.

If you run Example 6 by entering ``python3 -m da hello\_world06.da'', then you
will see that there now only two outputs. $p1$ greets $p2$, and $p2$ greets
$p1$. All is once again right with the world. Each process instance greets the
other without also greeting itself.

There are many examples of DistAlgo programs in which set difference is used in
this way to create a set of processes that includes all the processes in a set
to which the current process belongs, but which excludes the current process.
This is not surprising. Process classes define instances that will interact
with each other, but they do not usually need to interact with themselves. It
would be ugly to check the identity of the process the current instance is
attempting to interact with to verify that it is not unnecessarily
communicating with itself. Using set difference in this way lets us avoid all
that ugliness.
\end{document}
